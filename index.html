<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D20 Simulator</title>
    <style>
        /* --- CSS STYLING --- */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #1a1a1a; /* Dark outer background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disable default touch actions */
        }

        /* The 3D Container */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Settings Button (Top Right) */
        #settings-btn {
            pointer-events: auto;
            align-self: flex-end;
            margin: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            transition: transform 0.1s;
        }
        #settings-btn:active { transform: scale(0.9); }

        /* Roll Button (Bottom Center) */
        #roll-btn-container {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            margin-bottom: 50px;
        }

        #roll-btn {
            background-color: #ff4444;
            color: white;
            border: 4px solid #fff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: background 0.2s, transform 0.1s;
        }
        #roll-btn:active {
            background-color: #cc0000;
            transform: scale(0.95);
        }

        /* Settings Modal Overlay */
        #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            width: 80%;
            max-width: 300px;
            border: 2px solid #555;
        }

        .modal-content h2 { margin-top: 0; }

        .option-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .option-btn.active {
            background-color: #2e8b57; /* Matches board green */
            border-color: #4ade80;
            font-weight: bold;
        }

        #close-modal {
            margin-top: 20px;
            background: transparent;
            border: 1px solid #888;
            color: #ccc;
        }
    </style>
    
    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <button id="settings-btn" aria-label="Settings">⚙️</button>
        <div id="roll-btn-container">
            <button id="roll-btn">Roll</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <h2>Dice Settings</h2>
            <button class="option-btn active" data-type="standard">Standard (1-20)</button>
            <button class="option-btn" data-type="blank">Blank (No Numbers)</button>
            <button class="option-btn" data-type="fixed">Fixed (All 20s)</button>
            <button id="close-modal" class="option-btn">Close</button>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                board: 0x2e8b57,  
                dice: 0xcc0000,   
                text: 'white',
            },
            physics: {
                gravity: -45,     // Strong gravity
                restitution: 0.6, // Bounciness
                friction: 0.3     // Friction
            },
            diceRadius: 1.5,
            textureSize: 1024
        };

        // --- VARIABLES ---
        let scene, camera, renderer;
        let world, floorBody;
        let diceMesh = null;
        let diceBody = null;
        let walls = [];
        let currentDiceType = 'standard';
        
        // Raycaster for accurate wall placement
        const raycaster = new THREE.Raycaster();
        const planeMath = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Horizontal plane at y=0

        // --- INIT ---
        function init() {
            // 1. Three.js Setup
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.board);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 500);
            camera.position.set(0, 40, 15); // High angle
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 2. Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // 3. Physics Setup
            world = new CANNON.World();
            world.gravity.set(0, CONFIG.physics.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 20; // High iterations for stability

            // Materials
            const diceMat = new CANNON.Material();
            const wallMat = new CANNON.Material();
            
            const contactMat = new CANNON.ContactMaterial(wallMat, diceMat, {
                friction: CONFIG.physics.friction,
                restitution: CONFIG.physics.restitution
            });
            world.addContactMaterial(contactMat);

            // 4. Floor (Physics)
            const floorShape = new CANNON.Plane();
            floorBody = new CANNON.Body({ mass: 0, material: wallMat });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);

            // Floor (Visual Shadow Catcher)
            const shadowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.ShadowMaterial({ opacity: 0.4 })
            );
            shadowPlane.rotation.x = -Math.PI / 2;
            shadowPlane.receiveShadow = true;
            scene.add(shadowPlane);

            // 5. Walls & Events
            updateWalls(wallMat); // Initial Wall Setup
            
            window.addEventListener('resize', () => {
                onWindowResize();
                updateWalls(wallMat);
            });

            document.getElementById('roll-btn').addEventListener('click', rollDice);
            setupUI();

            animate();
        }

        // --- WALL GENERATION (RAYCASTING) ---
        function updateWalls(material) {
            // Remove old walls
            walls.forEach(b => world.removeBody(b));
            walls = [];

            // We cast rays from the 4 corners of the screen to the floor plane (y=0)
            // to find the exact visible boundary.
            const corners = [
                { x: -1, y: 1 },  // Top Left
                { x: 1, y: 1 },   // Top Right
                { x: -1, y: -1 }, // Bottom Left
                { x: 1, y: -1 }   // Bottom Right
            ];

            const points = corners.map(ndc => {
                raycaster.setFromCamera(new THREE.Vector2(ndc.x, ndc.y), camera);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeMath, target);
                return target; // Vector3 intersection with y=0
            });

            // Points order: TL, TR, BL, BR
            // Note: Camera is at z=15 looking at z=0. 
            // Top of screen is "far" (negative Z in view), Bottom is "near" (positive Z).
            // Actually, with camera.lookAt(0,0,0) from (0,40,15), 
            // the floor intersection geometry is a trapezoid.
            
            // To make a safe box, we find the min/max X and Z.
            // But a simple rectangular box might cut off corners of the trapezoid or leave gaps.
            // For a mobile phone "box" feel, we want walls at the Left, Right, Top, Bottom edges.
            
            const wallThickness = 50; // Very thick to prevent tunneling
            const wallHeight = 1000;  // Infinite height effect

            // Left Wall (Midpoint of TL and BL x)
            // We take the inner-most bounds to ensure nothing leaves screen
            // Actually, raycast gives exact edge.
            
            // We'll create 4 box walls oriented to match the average edges.
            // For simplicity in this perspective, we will take the max/min bounds 
            // and maybe angle them if we wanted perfection, but Axis Aligned walls are safer for physics.
            
            // Calculate Min/Max X and Z to form a bounding box
            // Note: This approximates the trapezoid as a rectangle, which might mean 
            // some floor is off screen or some screen has no floor. 
            // Given the high camera angle, a rectangle is a "good enough" approximation 
            // if we use the wider bottom or narrower top?
            // Let's use the intersection points directly to place walls.
            
            // Left Wall: Average X of Left side
            const leftX = (points[0].x + points[2].x) / 2;
            const rightX = (points[1].x + points[3].x) / 2;
            
            // Top Wall (Far): Average Z of Top side
            const topZ = (points[0].z + points[1].z) / 2;
            // Bottom Wall (Near): Average Z of Bottom side
            const bottomZ = (points[2].z + points[3].z) / 2;

            const width = Math.abs(rightX - leftX);
            const depth = Math.abs(bottomZ - topZ);
            const centerX = (leftX + rightX) / 2;
            const centerZ = (topZ + bottomZ) / 2;

            // Define walls relative to center
            const wallDefs = [
                // Right
                { 
                    pos: [rightX + wallThickness/2, wallHeight/2, centerZ], 
                    size: [wallThickness, wallHeight, depth + 20] 
                },
                // Left
                { 
                    pos: [leftX - wallThickness/2, wallHeight/2, centerZ], 
                    size: [wallThickness, wallHeight, depth + 20] 
                },
                // Top (Far)
                { 
                    pos: [centerX, wallHeight/2, topZ - wallThickness/2], 
                    size: [width + 20, wallHeight, wallThickness] 
                },
                // Bottom (Near)
                { 
                    pos: [centerX, wallHeight/2, bottomZ + wallThickness/2], 
                    size: [width + 20, wallHeight, wallThickness] 
                }
            ];

            wallDefs.forEach(def => {
                const shape = new CANNON.Box(new CANNON.Vec3(def.size[0]/2, def.size[1]/2, def.size[2]/2));
                const body = new CANNON.Body({ mass: 0, material: material });
                body.position.set(...def.pos);
                body.addShape(shape);
                world.addBody(body);
                walls.push(body);
            });
        }

        // --- TEXTURE GENERATION ---
        function createDiceTexture(type) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = CONFIG.textureSize;
            const cols = 5; 
            const rows = 4;
            const cellW = size / cols;
            const cellH = size / rows;

            canvas.width = size;
            canvas.height = size;

            // Background
            ctx.fillStyle = '#cc0000';
            ctx.fillRect(0, 0, size, size);

            if (type === 'blank') return new THREE.CanvasTexture(canvas);

            ctx.fillStyle = CONFIG.colors.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const fontSize = cellW * 0.35; 
            ctx.font = `bold ${fontSize}px Arial`;

            for (let i = 0; i < 20; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cx = col * cellW + cellW / 2;
                const cy = row * cellH + cellH / 2;

                let num = (i + 1).toString();
                if (type === 'fixed') num = '20';
                if (num === '6' || num === '9') num += '.';

                ctx.save();
                ctx.translate(cx, cy);
                
                // --- FIX: MIRROR TEXT ---
                // We scale X by -1 to flip the text horizontally.
                // This counteracts the UV mapping mirroring.
                ctx.scale(-1, 1); 
                
                ctx.fillText(num, 0, 0);
                ctx.restore();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- DICE LOGIC ---
        function createDice() {
            if (diceMesh) {
                scene.remove(diceMesh);
                diceMesh.geometry.dispose();
                diceMesh.material.dispose();
                world.removeBody(diceBody);
            }

            // Geometry & UVs
            const geometry = new THREE.IcosahedronGeometry(CONFIG.diceRadius, 0).toNonIndexed();
            const pos = geometry.attributes.position;
            const uvs = geometry.attributes.uv;
            
            const cols = 5;
            const uStep = 1 / cols;
            const vStep = 1 / 4;

            for (let i = 0; i < pos.count; i += 3) {
                const faceIndex = i / 3;
                const col = faceIndex % cols;
                const row = Math.floor(faceIndex / cols);

                const cU = col * uStep + uStep / 2;
                const cV = 1 - (row * vStep + vStep / 2);
                const r = uStep * 0.4; 

                // Triangle mapping inside grid cell
                uvs.setXY(i,     cU, cV + r);           // Top
                uvs.setXY(i + 1, cU + r * 0.866, cV - r * 0.5); // Bottom Right
                uvs.setXY(i + 2, cU - r * 0.866, cV - r * 0.5); // Bottom Left
            }
            geometry.attributes.uv.needsUpdate = true;
            geometry.computeVertexNormals();

            // Mesh
            const material = new THREE.MeshStandardMaterial({
                map: createDiceTexture(currentDiceType),
                color: 0xffffff,
                roughness: 0.1,
                metalness: 0.0,
                flatShading: true
            });
            diceMesh = new THREE.Mesh(geometry, material);
            diceMesh.castShadow = true;
            diceMesh.receiveShadow = true;
            scene.add(diceMesh);

            // Physics Body (Convex Hull)
            const vertices = [];
            for (let i = 0; i < pos.count; i++) {
                vertices.push(new CANNON.Vec3(pos.getX(i), pos.getY(i), pos.getZ(i)));
            }
            // Generate simplified faces list for Cannon (0,1,2 for every triplet)
            const faces = [];
            for (let i = 0; i < pos.count; i += 3) {
                faces.push([i, i+1, i+2]);
            }

            // Use exact geometry vertices for physics shape
            const shape = new CANNON.ConvexPolyhedron({ vertices, faces });
            
            diceBody = new CANNON.Body({
                mass: 5,
                shape: shape,
                material: world.defaultContactMaterial.materials[1] 
            });
            world.addBody(diceBody);
        }

        function rollDice() {
            // Recreate dice ensures fresh state
            createDice();

            // Calculate start position: Bottom center of visible area
            // We use raycaster logic again to find "Bottom" Z
            const target = new THREE.Vector3();
            raycaster.setFromCamera(new THREE.Vector2(0, -0.8), camera); // 0.8 down screen
            raycaster.ray.intersectPlane(planeMath, target);
            
            // Start position
            diceBody.position.set(0, 5, target.z);
            diceBody.velocity.set(0,0,0);
            diceBody.angularVelocity.set(0,0,0);

            // Forces
            // Throw UP (+Y) and INTO SCREEN (-Z)
            const rX = (Math.random() - 0.5) * 25; 
            const rY = 50 + Math.random() * 20;
            const rZ = -(40 + Math.random() * 20); // Throw towards -Z (top of screen)

            diceBody.velocity.set(rX, rY, rZ);

            // Spin
            const spin = 35;
            diceBody.angularVelocity.set(
                (Math.random() - 0.5) * spin,
                (Math.random() - 0.5) * spin,
                (Math.random() - 0.5) * spin
            );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            world.step(1 / 60);
            if (diceMesh && diceBody) {
                diceMesh.position.copy(diceBody.position);
                diceMesh.quaternion.copy(diceBody.quaternion);
            }
            renderer.render(scene, camera);
        }

        function setupUI() {
            const settingsBtn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const closeBtn = document.getElementById('close-modal');
            const options = document.querySelectorAll('.option-btn[data-type]');

            settingsBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
            closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });

            options.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    options.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentDiceType = e.target.dataset.type;
                });
            });
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
        }

        init();
    </script>
</body>
</html>


