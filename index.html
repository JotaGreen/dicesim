<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>D20 Simulator</title>
    <style>
        /* --- CSS STYLING --- */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #1a1a1a; /* Dark outer background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disable default touch actions */
        }

        /* The 3D Container */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed, though we handle buttons separately */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Settings Button (Top Right) */
        #settings-btn {
            pointer-events: auto;
            align-self: flex-end;
            margin: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            transition: transform 0.1s;
        }
        #settings-btn:active { transform: scale(0.9); }

        /* Roll Button (Bottom Center) */
        #roll-btn-container {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            margin-bottom: 50px;
        }

        #roll-btn {
            background-color: #ff4444;
            color: white;
            border: 4px solid #fff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: background 0.2s, transform 0.1s;
        }
        #roll-btn:active {
            background-color: #cc0000;
            transform: scale(0.95);
        }

        /* Settings Modal Overlay */
        #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            width: 80%;
            max-width: 300px;
            border: 2px solid #555;
        }

        .modal-content h2 { margin-top: 0; }

        .option-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .option-btn.active {
            background-color: #2e8b57; /* Matches board green */
            border-color: #4ade80;
            font-weight: bold;
        }

        #close-modal {
            margin-top: 20px;
            background: transparent;
            border: 1px solid #888;
            color: #ccc;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button id="settings-btn" aria-label="Settings">⚙️</button>
        
        <div id="roll-btn-container">
            <button id="roll-btn">Roll</button>
        </div>
    </div>

    <div id="settings-modal">
        <div class="modal-content">
            <h2>Dice Settings</h2>
            <button class="option-btn active" data-type="standard">Standard (1-20)</button>
            <button class="option-btn" data-type="blank">Blank (No Numbers)</button>
            <button class="option-btn" data-type="fixed">Fixed (All 20s)</button>
            
            <button id="close-modal" class="option-btn">Close</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                board: 0x2e8b57,  // Sea Green
                dice: 0xcc0000,   // Red
                text: 'white',
                light: 0xffffff
            },
            physics: {
                gravity: -25,     // Strong gravity for snappy rolls
                restitution: 0.5, // Bounciness
                friction: 0.1
            },
            diceRadius: 1.5
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let world; // Physics world
        let diceMesh = null;
        let diceBody = null;
        let floorBody;
        
        // Wall bodies array to keep track and update them on resize
        let walls = []; 

        // State
        let currentDiceType = 'standard'; // 'standard', 'blank', 'fixed'
        let isRolling = false;

        // --- INITIALIZATION ---
        function init() {
            console.log("Initializing D20 Simulator...");

            // 1. Setup Three.js Scene
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.board);

            // 2. Setup Camera (Perspective, looking down)
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
            // Position camera high up and slightly back to see the 3D depth
            camera.position.set(0, 30, 10); 
            camera.lookAt(0, 0, 0);

            // 3. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. Setup Physics World (Cannon-es)
            world = new CANNON.World();
            world.gravity.set(0, CONFIG.physics.gravity, 0);
            
            // Materials
            const defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: CONFIG.physics.friction,
                restitution: CONFIG.physics.restitution,
            });
            world.addContactMaterial(defaultContactMaterial);

            // 6. Create Floor (Physics only, visual is background color)
            // Infinite plane at y=0
            const floorShape = new CANNON.Plane();
            floorBody = new CANNON.Body({
                mass: 0, // Static
                material: defaultMaterial
            });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to be flat
            world.addBody(floorBody);
            
            // Shadow receiving plane (Visual only)
            const shadowPlaneGeo = new THREE.PlaneGeometry(100, 100);
            const shadowPlaneMat = new THREE.ShadowMaterial({ opacity: 0.3 });
            const shadowPlane = new THREE.Mesh(shadowPlaneGeo, shadowPlaneMat);
            shadowPlane.rotation.x = -Math.PI / 2;
            shadowPlane.receiveShadow = true;
            scene.add(shadowPlane);

            // 7. Setup Walls based on screen size
            updateWalls();

            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            setupUI();

            // 9. Start Loop
            animate();
            console.log("Initialization Complete.");
        }

        // --- WALLS LOGIC ---
        // We need invisible walls so the dice stays on screen.
        // We calculate the visible width at y=0 (floor level) based on camera.
        function updateWalls() {
            // Remove old walls
            walls.forEach(body => world.removeBody(body));
            walls = [];

            // Calculate visible boundaries at y=0
            // Math: tan(fov/2) * distance = height/2
            const dist = camera.position.y;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;

            const w = visibleWidth / 2;
            const h = visibleHeight / 2;
            const wallThickness = 5;

            // Material
            const wallMat = new CANNON.Material();

            // Create 4 walls (Left, Right, Top, Bottom)
            // Note: Camera looks at 0,0,0. +Z is 'down' on screen (roughly), -Z is 'up'.
            // Because camera is at (0,30,10) looking at (0,0,0), the view is tilted.
            // We approximate walls around the center (0,0).
            
            const wallDefinitions = [
                { pos: [w, 5, 0], size: [wallThickness, 10, h*2] },   // Right
                { pos: [-w, 5, 0], size: [wallThickness, 10, h*2] },  // Left
                { pos: [0, 5, -h], size: [w*2, 10, wallThickness] },  // Top (Far)
                { pos: [0, 5, h], size: [w*2, 10, wallThickness] }    // Bottom (Near)
            ];

            wallDefinitions.forEach(def => {
                const shape = new CANNON.Box(new CANNON.Vec3(def.size[0], def.size[1], def.size[2]));
                const body = new CANNON.Body({ mass: 0, material: wallMat });
                body.position.set(...def.pos);
                body.addShape(shape);
                world.addBody(body);
                walls.push(body);
            });
            
            // Debug: console.log(`Walls updated. Visible area: ${visibleWidth.toFixed(2)} x ${visibleHeight.toFixed(2)}`);
        }

        // --- DICE GENERATION ---
        
        // Helper to draw text on canvas for texture
        function createDiceTexture(type) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512; // Texture resolution
            // We will create a grid texture. 5 columns, 4 rows = 20 cells.
            const cols = 5; 
            const rows = 4;
            const cellW = size / cols;
            const cellH = size / rows;

            canvas.width = size;
            canvas.height = size;

            // Fill background (Red)
            ctx.fillStyle = '#cc0000'; // Match CONFIG.colors.dice
            ctx.fillRect(0, 0, size, size);

            if (type === 'blank') return new THREE.CanvasTexture(canvas);

            // Draw numbers
            ctx.fillStyle = CONFIG.colors.text;
            ctx.font = 'bold 60px Arial'; // Adjust size
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // D20 standard mapping is complex. We will map linearly 1-20
            // and assign faces later.
            for (let i = 0; i < 20; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                const x = col * cellW + cellW / 2;
                const y = row * cellH + cellH / 2;

                // Debug grid lines (optional, commented out)
                // ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.strokeRect(col*cellW, row*cellH, cellW, cellH);

                let numberStr = (i + 1).toString();
                if (type === 'fixed') numberStr = '20';
                
                // 6 and 9 underline logic
                if (numberStr === '6' || numberStr === '9') {
                    numberStr += '.';
                }

                ctx.save();
                ctx.translate(x, y);
                // Randomly rotate text slightly for organic feel? No, keep it straight.
                ctx.fillText(numberStr, 0, 0);
                ctx.restore();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createDice() {
            // Remove existing dice if any
            if (diceMesh) {
                scene.remove(diceMesh);
                diceMesh.geometry.dispose();
                diceMesh.material.dispose();
                world.removeBody(diceBody);
                diceMesh = null;
                diceBody = null;
            }

            // 1. Geometry
            // Icosahedron: Radius, Detail 0 = 20 faces.
            const geomOriginal = new THREE.IcosahedronGeometry(CONFIG.diceRadius, 0);
            
            // To map textures to specific faces, we need non-indexed geometry (unique vertices per face)
            const geometry = geomOriginal.toNonIndexed();
            
            // Calculate UVs to map to our grid texture
            const uvs = geometry.attributes.uv;
            const count = uvs.count; // Should be 20 faces * 3 verts = 60
            
            const cols = 5; 
            const rows = 4;

            // Standard Icosahedron face order isn't strictly linear 1-20 in adjacency,
            // but for a simulator we just need each face to show a unique number.
            for (let i = 0; i < count; i += 3) {
                const faceIndex = i / 3; // 0 to 19
                
                // Determine grid cell for this face
                const col = faceIndex % cols;
                const row = Math.floor(faceIndex / cols);

                // UV coordinates in grid (0..1)
                // We want to map the triangle of the face to the center of the square grid cell.
                // Simple mapping: Triangle fits inside the square box.
                const uSize = 1 / cols;
                const vSize = 1 / rows;
                
                const uBase = col * uSize;
                const vBase = 1 - (row * vSize) - vSize; // Flip Y for canvas coords

                // Triangle UVs centered in the box
                // Top-Center, Bottom-Left, Bottom-Right (approximate for equilateral)
                // We just need the number to be in the middle of the face.
                
                // Valid UV mapping for a triangle inside a square box:
                // Vertex 0: (0.5, 0.9) relative to box
                // Vertex 1: (0.1, 0.1) relative to box
                // Vertex 2: (0.9, 0.1) relative to box
                
                // Note: The vertex order in Icosahedron determines orientation.
                // We assign them generically.
                
                uvs.setXY(i,     uBase + 0.5 * uSize, vBase + 0.85 * vSize);
                uvs.setXY(i + 1, uBase + 0.1 * uSize, vBase + 0.15 * vSize);
                uvs.setXY(i + 2, uBase + 0.9 * uSize, vBase + 0.15 * vSize);
            }
            
            geometry.attributes.uv.needsUpdate = true;
            geometry.computeVertexNormals(); // Important for lighting

            // 2. Material
            const texture = createDiceTexture(currentDiceType);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                color: 0xffffff,
                roughness: 0.2,
                metalness: 0.1,
                flatShading: true // Gives the 'poly' look, not smooth sphere
            });

            // 3. Mesh
            diceMesh = new THREE.Mesh(geometry, material);
            diceMesh.castShadow = true;
            scene.add(diceMesh);

            // 4. Physics Body
            // We use a ConvexPolyhedron for perfect collisions matching the mesh
            // Wait - Cannon-es doesn't have a built-in Icosahedron helper, 
            // but we can approximate it well enough with a Sphere for simple rolling
            // OR use the vertices to build a hull.
            // For a D20, a convex hull is best for true "stopping on a face".
            
            // Generating ConvexPolyhedron from Three.js Geometry vertices
            const vertices = [];
            const posAttr = geometry.attributes.position;
            for(let i=0; i<posAttr.count; i++){
                vertices.push(new CANNON.Vec3(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i)));
            }
            
            // Indices (since it's non-indexed, we just list 0,1,2...)
            const faces = [];
            for(let i=0; i<posAttr.count; i+=3){
                faces.push([i, i+1, i+2]);
            }

            // Note: Cannon needs merged vertices for performance usually, 
            // but for one single die, raw non-indexed hull is usually okay if faces are defined.
            // Actually, Cannon's ConvexPolyhedron requires unique vertices and indexed faces.
            // Let's create a cleaner shape manually or use a simpler approximation.
            // Simplest robust way for D20 without external hull generators:
            // Use Cannon's Cylinder or Sphere? No, it won't land flat.
            // Let's use the vertices of a standard Icosahedron (indexed).
            
            // Standard indexed vertices for Icosahedron (12 verts)
            const t = (1.0 + Math.sqrt(5.0)) / 2.0;
            const r = CONFIG.diceRadius; 
            // Normalized then scaled
            const vertsRaw = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ].map(v => {
                const vec = new CANNON.Vec3(v[0], v[1], v[2]);
                vec.normalize();
                vec.scale(r, vec);
                return vec;
            });

            const facesRaw = [
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];

            const diceShape = new CANNON.ConvexPolyhedron({
                vertices: vertsRaw,
                faces: facesRaw
            });

            diceBody = new CANNON.Body({
                mass: 1,
                shape: diceShape,
                linearDamping: 0.05,
                angularDamping: 0.05
            });
            
            world.addBody(diceBody);
        }

        // --- GAMEPLAY LOGIC ---

        function rollDice() {
            console.log("Rolling...");
            
            // 1. Create new die
            createDice();

            // 2. Set Start Position (Bottom Center, off floor)
            // Visible height check
            const dist = camera.position.y;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            
            // Start slightly below center, but within view
            diceBody.position.set(0, 5, visibleHeight/3); 
            
            // 3. Apply Force (Launch Upwards and slightly back/forward for randomness)
            const forceY = 30 + Math.random() * 10; // Up
            const forceZ = -(20 + Math.random() * 10); // Into the screen (Up on 2D)
            const forceX = (Math.random() - 0.5) * 10; // Slight side wobble

            // Apply Impulse (Force over time instant)
            // Point of application is center of mass
            diceBody.velocity.set(forceX, forceY, forceZ);

            // 4. Apply Torque (Spin)
            const torqueAmt = 15;
            diceBody.angularVelocity.set(
                (Math.random() - 0.5) * torqueAmt,
                (Math.random() - 0.5) * torqueAmt,
                (Math.random() - 0.5) * torqueAmt
            );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateWalls();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Step physics
            world.step(1 / 60);

            // Sync visual mesh with physics body
            if (diceMesh && diceBody) {
                diceMesh.position.copy(diceBody.position);
                diceMesh.quaternion.copy(diceBody.quaternion);
            }

            renderer.render(scene, camera);
        }

        // --- UI LOGIC ---
        function setupUI() {
            const settingsBtn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const closeBtn = document.getElementById('close-modal');
            const options = document.querySelectorAll('.option-btn[data-type]');

            settingsBtn.addEventListener('click', () => {
                modal.style.display = 'flex';
            });

            closeBtn.addEventListener('click', () => {
                modal.style.display = 'none';
            });

            options.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Update Active State
                    options.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    // Update Logic
                    currentDiceType = e.target.dataset.type;
                    console.log(`Dice type set to: ${currentDiceType}`);
                });
            });
            
            // Close modal on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.style.display = 'none';
            });
        }

        // Start everything
        init();

    </script>
</body>
</html>
