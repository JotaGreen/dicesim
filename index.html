<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D20 Simulator</title>
    <style>
        /* --- CSS STYLING --- */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #1a1a1a; /* Dark outer background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disable default touch actions */
        }

        /* The 3D Container */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Settings Button (Top Right) */
        #settings-btn {
            pointer-events: auto;
            align-self: flex-end;
            margin: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            transition: transform 0.1s;
        }
        #settings-btn:active { transform: scale(0.9); }

        /* Roll Button (Bottom Center) */
        #roll-btn-container {
            pointer-events: auto;
            display: flex;
            justify-content: center;
            margin-bottom: 50px;
        }

        #roll-btn {
            background-color: #ff4444;
            color: white;
            border: 4px solid #fff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: background 0.2s, transform 0.1s;
        }
        #roll-btn:active {
            background-color: #cc0000;
            transform: scale(0.95);
        }

        /* Settings Modal Overlay */
        #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        .modal-content {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            width: 80%;
            max-width: 300px;
            border: 2px solid #555;
        }

        .modal-content h2 { margin-top: 0; }

        .option-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }
        
        .option-btn.active {
            background-color: #2e8b57; /* Matches board green */
            border-color: #4ade80;
            font-weight: bold;
        }

        #close-modal {
            margin-top: 20px;
            background: transparent;
            border: 1px solid #888;
            color: #ccc;
        }
    </style>
    
    <!-- Import Maps for Three.js and Cannon-es -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- Settings Button -->
        <button id="settings-btn" aria-label="Settings">⚙️</button>
        
        <!-- Roll Button -->
        <div id="roll-btn-container">
            <button id="roll-btn">Roll</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <h2>Dice Settings</h2>
            <button class="option-btn active" data-type="standard">Standard (1-20)</button>
            <button class="option-btn" data-type="blank">Blank (No Numbers)</button>
            <button class="option-btn" data-type="fixed">Fixed (All 20s)</button>
            
            <button id="close-modal" class="option-btn">Close</button>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                board: 0x2e8b57,  // Sea Green
                dice: 0xcc0000,   // Red
                text: 'white',
                light: 0xffffff
            },
            physics: {
                gravity: -35,     // Strong gravity for snappy rolls
                restitution: 0.8, // Bounciness (0.0 - 1.0)
                friction: 0.05    // Lower friction to let it slide/roll more
            },
            diceRadius: 1.5,
            textureSize: 1024     // High res for crisp text
        };

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer;
        let world; // Physics world
        let diceMesh = null;
        let diceBody = null;
        let floorBody;
        let walls = []; 
        let currentDiceType = 'standard'; 

        // --- INITIALIZATION ---
        function init() {
            console.log("Initializing D20 Simulator...");

            // 1. Setup Three.js Scene
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.board);

            // 2. Setup Camera
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
            camera.position.set(0, 30, 10); 
            camera.lookAt(0, 0, 0);

            // 3. Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(10, 25, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            // Optimize shadow camera bounds
            dirLight.shadow.camera.left = -15;
            dirLight.shadow.camera.right = 15;
            dirLight.shadow.camera.top = 15;
            dirLight.shadow.camera.bottom = -15;
            scene.add(dirLight);

            // 5. Setup Physics World
            world = new CANNON.World();
            world.gravity.set(0, CONFIG.physics.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            // Materials
            const diceMaterial = new CANNON.Material('dice');
            const floorMaterial = new CANNON.Material('floor');
            
            const contactMaterial = new CANNON.ContactMaterial(floorMaterial, diceMaterial, {
                friction: CONFIG.physics.friction,
                restitution: CONFIG.physics.restitution, // Bouncy!
                contactEquationStiffness: 1e7,
                contactEquationRelaxation: 3
            });
            
            world.addContactMaterial(contactMaterial);

            // 6. Create Floor
            const floorShape = new CANNON.Plane();
            floorBody = new CANNON.Body({ mass: 0, material: floorMaterial });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);
            
            // Shadow Plane (Visual)
            const shadowPlaneGeo = new THREE.PlaneGeometry(100, 100);
            const shadowPlaneMat = new THREE.ShadowMaterial({ opacity: 0.4 });
            const shadowPlane = new THREE.Mesh(shadowPlaneGeo, shadowPlaneMat);
            shadowPlane.rotation.x = -Math.PI / 2;
            shadowPlane.receiveShadow = true;
            scene.add(shadowPlane);

            // 7. Setup Walls
            // We use the same material logic for walls as floor to keep dice bouncing off them
            updateWalls(floorMaterial);

            // 8. Event Listeners
            window.addEventListener('resize', () => {
                onWindowResize();
                updateWalls(floorMaterial);
            });
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            setupUI();

            // 9. Start Loop
            animate();
            console.log("System Ready.");
        }

        function updateWalls(material) {
            walls.forEach(body => world.removeBody(body));
            walls = [];

            const dist = camera.position.y;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;

            const w = visibleWidth / 2;
            const h = visibleHeight / 2;
            const thick = 5;
            const height = 20;

            const wallDefs = [
                { pos: [w + thick/2, height/2, 0], size: [thick, height, h*2.5] }, // Right
                { pos: [-(w + thick/2), height/2, 0], size: [thick, height, h*2.5] }, // Left
                { pos: [0, height/2, -(h + thick/2)], size: [w*2.5, height, thick] }, // Top
                { pos: [0, height/2, h + thick/2], size: [w*2.5, height, thick] }  // Bottom
            ];

            wallDefs.forEach(def => {
                const shape = new CANNON.Box(new CANNON.Vec3(def.size[0]/2, def.size[1]/2, def.size[2]/2));
                const body = new CANNON.Body({ mass: 0, material: material });
                body.position.set(...def.pos);
                body.addShape(shape);
                world.addBody(body);
                walls.push(body);
            });
        }

        // --- TEXTURE GENERATION ---
        
        function createDiceTexture(type) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = CONFIG.textureSize;
            
            // Grid: 5 cols x 4 rows = 20 faces
            const cols = 5; 
            const rows = 4;
            const cellW = size / cols;
            const cellH = size / rows;

            canvas.width = size;
            canvas.height = size;

            // Fill Background
            ctx.fillStyle = '#cc0000'; // Red
            ctx.fillRect(0, 0, size, size);

            if (type === 'blank') return new THREE.CanvasTexture(canvas);

            // Text Settings
            ctx.fillStyle = CONFIG.colors.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Font sizing: Needs to be small enough to fit inside the triangular slice
            // The safe radius of an inscribed circle in our UV triangle is roughly cellW * 0.25
            const fontSize = cellW * 0.35; 
            ctx.font = `bold ${fontSize}px Arial`;

            for (let i = 0; i < 20; i++) {
                const col = i % cols;
                const row = Math.floor(i / cols);
                
                const centerX = col * cellW + cellW / 2;
                const centerY = row * cellH + cellH / 2;

                let num = (i + 1).toString();
                if (type === 'fixed') num = '20';
                
                // Add dot for 6 and 9 to distinguish
                if (num === '6' || num === '9') num += '.';

                ctx.save();
                ctx.translate(centerX, centerY);
                
                // Optional: Debug Circle to check centering
                // ctx.beginPath(); ctx.arc(0,0, cellW*0.2, 0, Math.PI*2); ctx.stroke();

                ctx.fillText(num, 0, 0);
                ctx.restore();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace; // Correct color profile
            return tex;
        }

        function createDice() {
            // Cleanup
            if (diceMesh) {
                scene.remove(diceMesh);
                diceMesh.geometry.dispose();
                diceMesh.material.dispose();
                world.removeBody(diceBody);
                diceMesh = null;
                diceBody = null;
            }

            // 1. Geometry (Non-indexed for custom UVs per face)
            const geometry = new THREE.IcosahedronGeometry(CONFIG.diceRadius, 0).toNonIndexed();
            const pos = geometry.attributes.position;
            const uvs = geometry.attributes.uv;
            
            // 2. Map UVs to Grid
            // We have 20 faces (60 vertices). 
            // We map each 3-vertex face to the CENTER of a grid cell.
            const cols = 5;
            const uStep = 1 / cols;
            const vStep = 1 / 4;

            for (let i = 0; i < pos.count; i += 3) {
                const faceIndex = i / 3;
                
                // Calculate grid cell
                const col = faceIndex % cols;
                const row = Math.floor(faceIndex / cols);

                // Center of the cell in UV space (0..1)
                const cU = col * uStep + uStep / 2;
                // Invert V because canvas Y is top-down, UV V is bottom-up
                const cV = 1 - (row * vStep + vStep / 2);

                // We define a small equilateral triangle centered at (cU, cV)
                // This triangle sits inside the square cell.
                // Radius in UV space (approx half the width of the cell)
                const r = uStep * 0.4; 

                // Vertex 1: Top
                uvs.setXY(i,     cU, cV + r);
                // Vertex 2: Bottom Right
                uvs.setXY(i + 1, cU + r * 0.866, cV - r * 0.5);
                // Vertex 3: Bottom Left
                uvs.setXY(i + 2, cU - r * 0.866, cV - r * 0.5);
            }
            
            geometry.attributes.uv.needsUpdate = true;
            geometry.computeVertexNormals();

            // 3. Material
            const material = new THREE.MeshStandardMaterial({
                map: createDiceTexture(currentDiceType),
                color: 0xffffff,
                roughness: 0.1, // Shiny
                metalness: 0.0,
                flatShading: true
            });

            diceMesh = new THREE.Mesh(geometry, material);
            diceMesh.castShadow = true;
            diceMesh.receiveShadow = true;
            scene.add(diceMesh);

            // 4. Physics Body (Icosahedron Hull)
            // Create vertices for Cannon
            const vertices = [];
            for (let i = 0; i < pos.count; i++) {
                vertices.push(new CANNON.Vec3(pos.getX(i), pos.getY(i), pos.getZ(i)));
            }
            
            // Create faces (simple 0,1,2 indexing because we are non-indexed)
            const faces = [];
            for (let i = 0; i < pos.count; i += 3) {
                faces.push([i, i+1, i+2]);
            }

            // Note: ConvexPolyhedron requires unique vertices for stability usually, 
            // but providing the full triangle list often works for simple shapes.
            // For robustness, we fallback to the indexed vertices of a standard icosahedron
            // to ensure the physics shape is perfectly watertight.
            
            const t = (1.0 + Math.sqrt(5.0)) / 2.0;
            const r = CONFIG.diceRadius; 
            const rawVerts = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ].map(v => new CANNON.Vec3(v[0], v[1], v[2]).scale(1/Math.sqrt(1+t*t) * r)); // Normalize & Scale

            const rawFaces = [
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];

            const shape = new CANNON.ConvexPolyhedron({
                vertices: rawVerts,
                faces: rawFaces
            });

            // "Dice" material is already defined in contact material in init
            const diceMat = world.defaultContactMaterial.materials[1]; 

            diceBody = new CANNON.Body({
                mass: 5, // Slightly heavier for stability
                shape: shape,
                material: diceMat,
                linearDamping: 0.0,
                angularDamping: 0.0
            });
            
            world.addBody(diceBody);
        }

        function rollDice() {
            if (!diceMesh) createDice();
            else {
                // Reset visual and physics if it exists
                world.removeBody(diceBody);
                createDice(); // Recreate to ensure clean state
            }

            console.log("Rolling...");

            // 1. Position: Bottom Center, just above floor
            // Get visible height to determine "bottom"
            const dist = camera.position.y;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            
            // Z positive is "bottom" of screen in this camera view
            const startZ = visibleHeight * 0.4; 
            diceBody.position.set(0, 3, startZ);
            diceBody.velocity.set(0,0,0);
            diceBody.angularVelocity.set(0,0,0);

            // 2. Random Launch Forces
            const force = 70; // Magnitude
            
            // Random x spread
            const rX = (Math.random() - 0.5) * 20; 
            // Always throw UP (+y)
            const rY = 50 + Math.random() * 20;
            // Always throw AWAY (-z) towards center/top
            const rZ = -(50 + Math.random() * 30);

            diceBody.velocity.set(rX, rY, rZ);

            // 3. Random Spin (Torque)
            // High spin makes it look realistic
            const spin = 30;
            diceBody.angularVelocity.set(
                (Math.random() - 0.5) * spin,
                (Math.random() - 0.5) * spin,
                (Math.random() - 0.5) * spin
            );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update Physics
            world.step(1 / 60);

            // Sync
            if (diceMesh && diceBody) {
                diceMesh.position.copy(diceBody.position);
                diceMesh.quaternion.copy(diceBody.quaternion);
            }

            renderer.render(scene, camera);
        }

        function setupUI() {
            const settingsBtn = document.getElementById('settings-btn');
            const modal = document.getElementById('settings-modal');
            const closeBtn = document.getElementById('close-modal');
            const options = document.querySelectorAll('.option-btn[data-type]');

            settingsBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
            closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });

            options.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    options.forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentDiceType = e.target.dataset.type;
                });
            });
            
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
        }

        init();
    </script>
</body>
</html>
